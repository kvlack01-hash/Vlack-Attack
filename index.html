<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vlack Attack Beat Randomizer</title>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; text-align: center; background: #f0f2f5; padding: 20px; }
        .container { background: white; max-width: 1300px; margin: 0 auto; padding: 30px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        #output { background: white; margin: 20px 0; min-height: 520px; border: 1px solid #e1e4e8; border-radius: 12px; display: flex; justify-content; align-items: center; overflow-x: auto; }
        .controls { display: flex; justify-content: center; align-items: center; padding: 20px; background: #f8f9fa; border-radius: 12px; border: 1px solid #eee; flex-wrap: wrap; gap: 15px; }
        .control-group { display: flex; flex-direction: column; align-items: flex-start; gap: 5px; }
        button, select { padding: 10px 12px; cursor: pointer; border-radius: 8px; border: 1px solid #ced4da; background: white; font-weight: bold; }
        #gen-btn { background: #27ae60; color: white; border: none; padding: 12px 25px; }
        .label-text { font-size: 0.8rem; font-weight: bold; color: #777; text-transform: uppercase; }
        .vf-flag { display: none !important; }
        select:disabled { opacity: 0.5; cursor: not-allowed; background: #f5f5f5; }
    </style>
</head>
<body>

<div id="output"></div>

<div class="controls">
    <div class="control-group">
        <span class="label-text">Element</span>
        <select id="element-select">
            <option value="ride">Ride</option>
            <option value="hi-hat">Hi-Hat</option>
        </select>
    </div>

    <div class="control-group">
        <span class="label-text">Ride Pattern</span>
        <select id="cymbal-select"></select>
    </div>

    <div class="control-group">
        <span class="label-text">Left Foot</span>
        <select id="foot-select"></select>
    </div>
    
    <button id="gen-btn">Randomize Kick/Snare</button>
    
    <div class="control-group">
        <span class="label-text">Tempo: <span id="bpm-display">90</span> BPM</span>
        <input type="range" id="tempo-slider" min="40" max="220" value="90">
    </div>

    <div class="control-group">
        <span class="label-text">Pocket: <span id="pocket-display">0</span>%</span>
        <input type="range" id="pocket-slider" min="0" max="30" value="0">
    </div>

    <div class="control-group">
        <span class="label-text">Drum Kit</span>
        <select id="kit-select">
            <option value="studio">Studio</option>
            <option value="jazz">Jazz</option>
            <option value="lo-fi">Lo-Fi</option>
            <option value="muffled">Muffled</option>
            <option value="boomy">Boomy</option>
            <option value="metal">Metal</option>
        </select>
    </div>

    <button id="metro-btn" style="background: #3498db; color: white;">Play Beat</button>
    <div style="display: flex; gap: 15px; align-items: center; background: #fff; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
        <label><input type="checkbox" id="triplet-mode"> Triplet Mode</label>
        <label><input type="checkbox" id="accent-mode"> Accents (Ride)</label>
        <label><input type="checkbox" id="freeze-bottom"> Freeze Kick/Snare</label>
    </div>
</div>

<script>
const VF = Vex.Flow;

// --- GLOBAL STATE ---
let audioCtx = null;
let buffers = {};
let isPlaying = false;
let currentBeat = 0;
let nextNoteTime = 0.0;
let timerID = null;
let currentMid = [];
let activeHH = null; // Reserved for Hi-Hat Choke Logic

// --- RHYTHM DATA ---
const tCymPlain = ['down beats', 'shuffle', 'swing', '3:2 (down)', '3:2 (up)', '3:4 v1', '3:4 v2', '3:4 v3'];
const tCymAcc = ['shuffle', 'swing', '3:2 (down)', '3:2 (up)', '3:2 (down) shuffle', '3:2 (up) shuffle', '3:4 v1', '3:4 v2', '3:4 v3'];
const tCym = { 
    'down beats': [1,0,0], 'shuffle': [1,0,1], 'swing': [1,0,0,1,0,1],
    '3:2 (down)': [1,0,1,0,1,0, 1,0,1,0,1,0], '3:2 (up)': [0,1,0,1,0,1, 0,1,0,1,0,1],
    '3:4 v1': [1,1,1,0,1,1,1,0,1,1,1,0], '3:4 v2': [1,0,1,1,1,0,1,1,1,0,1,1], '3:4 v3': [0,1,1,1,0,1,1,1,0,1,1,1],
    '3:2 (down) shuffle': [1,0,1,0,1,0], '3:2 (up) shuffle': [0,1,0,1,0,1]
};
const tFoot = { 'down beats': [1,0,0], '2 and 4': [0,0,0,1,0,0], '3:2 (down)': [1,0,1,0,1,0], '3:2 (up)': [0,1,0,1,0,1] };
const sCymPlain = ['down beats', 'up beats', 'eighth notes', 'e a', '1 e &', 'e & a', '1 & a', '1 e a'];
const sCymAcc = ['down beats', 'up beats', '1 e &', 'e & a', '1 & a', '1 e a'];
const sCym = {
    'down beats': [1,0,0,0], 'up beats': [0,0,1,0], 'eighth notes': [1,0,1,0],
    'e a': [0,1,0,1], '1 e &': [1,1,1,0], 'e & a': [0,1,1,1],
    '1 & a': [1,0,1,1], '1 e a': [1,1,0,1]
};
const sFoot = { 'down beats': [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0], '2 and 4': [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0], 'eighth notes': [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0] };
const tMidPool = [[1,0,0], [0,1,0], [1,0,1], [0,0,1], [1,1,0], [0,1,1]];
const sMidPool = [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1], [1,0,1,0], [0,1,0,1], [1,1,0,0], [0,1,1,0], [0,0,1,1], [1,0,0,1], [1,1,1,0], [0,1,1,1], [1,0,1,1], [1,1,0,1]];

// Generate foot pattern based on hi-hat accent pattern
// Foot clamps down after each open hi-hat
function getFootPatternForHiHatAccents(cymbalPattern, isTriplet = false) {
    if (isTriplet) {
        // Triplet mode foot patterns
        const tripletFootPatterns = {
            'shuffle': [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'swing': [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
            '3:2 (down)': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            '3:2 (up)': [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
            '3:2 (down) shuffle': [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            '3:2 (up) shuffle': [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            '3:4 v1': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            '3:4 v2': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            '3:4 v3': [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]
        };
        return tripletFootPatterns[cymbalPattern] || null;
    } else {
        // Standard mode foot patterns (16th note subdivision)
        const standardFootPatterns = {
            'down beats': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            'up beats': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            '1 e &': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            'e & a': [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
            '1 & a': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            '1 e a': [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]
        };
        return standardFootPatterns[cymbalPattern] || null;
    }
}

// --- UI & NOTATION ---
function getAccentLogic(patternName, index, isHit) {
    if (!document.getElementById('accent-mode').checked || !isHit) return false;
    const isTri = document.getElementById("triplet-mode").checked;
    if (isTri) {
        const pos3 = index % 3, pos6 = index % 6, pos12 = index % 12;
        switch(patternName) {
            case 'shuffle': return pos3 === 0;
            case 'swing': return pos6 === 0;
            case '3:2 (down)': return (pos12 === 0 || pos12 === 4 || pos12 === 8);
            case '3:2 (up)': return (pos12 === 2 || pos12 === 6 || pos12 === 10);
            case '3:2 (down) shuffle': return (pos6 === 0 || pos6 === 4);
            case '3:2 (up) shuffle': return (pos6 === 1 || pos6 === 3);
            case '3:4 v1': return (pos12 === 2 || pos12 === 6 || pos12 === 10);
            case '3:4 v2': return (pos12 === 0 || pos12 === 4 || pos12 === 8);
            case '3:4 v3': return (pos12 === 3 || pos12 === 7 || pos12 === 11);
            default: return false;
        }
    } else {
        const pos = index % 4;
        switch(patternName) {
            case 'down beats': return pos === 0;
            case 'up beats': return pos === 2;
            case '1 e &': return pos === 2;
            case 'e & a': return pos === 3;
            case '1 & a': return pos === 0;
            case '1 e a': return pos === 1;
            default: return false;
        }
    }
}

function updateFootPatternForHiHatAccents() {
    const isAccent = document.getElementById("accent-mode").checked;
    const element = document.getElementById('element-select').value;
    const fSel = document.getElementById("foot-select");
    const isTri = document.getElementById("triplet-mode").checked;
    
    // If accent mode is on AND hi-hat is selected, 
    // the foot pattern is determined by the hi-hat pattern (for both standard and triplet)
    if (isAccent && element === 'hi-hat') {
        fSel.disabled = true;
    } else {
        fSel.disabled = false;
    }
}

function updateMenus() {
    const isTri = document.getElementById("triplet-mode").checked;
    const isAcc = document.getElementById("accent-mode").checked;
    const cSel = document.getElementById("cymbal-select");
    const previousCymbal = cSel.value;
    const fSel = document.getElementById("foot-select");
    const previousFoot = fSel.value;

    cSel.innerHTML = "";
    let cymList = isTri ? (isAcc ? tCymAcc : tCymPlain) : (isAcc ? sCymAcc : sCymPlain);
    cymList.forEach(k => { 
        let o = document.createElement("option"); o.value = k; o.text = k.trim(); cSel.add(o); 
    });
    cSel.value = Array.from(cSel.options).some(opt => opt.value === previousCymbal) ? previousCymbal : cSel.options[0].value;

    fSel.innerHTML = "";
    let fList = isTri ? Object.keys(tFoot) : Object.keys(sFoot);
    fList.forEach(k => { 
        let o = document.createElement("option"); o.value = k; o.text = k; fSel.add(o); 
    });
    fSel.value = Array.from(fSel.options).some(opt => opt.value === previousFoot) ? previousFoot : fSel.options[0].value;
    
    // Update foot pattern based on hi-hat accents
    updateFootPatternForHiHatAccents();
}

function createNote(vIdx, dur, isHit, bIdx, isAcc = false) {
    let key, stem, restKey;
    const element = document.getElementById('element-select').value;
    let cleanDur = dur.replace('r', '');
    let actualRest = !isHit || dur.includes('r');

    if (vIdx === 0) {
        stem = 1; 
        restKey = "G/5/r";
        key = "G/5/x2";
        if (isHit && !actualRest) {
            key = (element === 'hi-hat') ? "G/5/x2" : (isAcc ? "G/5/d2" : "G/5/x2");
        }
    } else if (vIdx === 1) {
        key = (bIdx % 2 === 0) ? "F/4" : "C/5"; 
        stem = -1; 
        restKey = (bIdx % 2 === 0) ? "F/4/r" : "C/5/r";
    } else {
        key = "B/4/x2"; 
        stem = -1; 
        restKey = "B/4/r";
    }

    const note = new VF.StaveNote({ 
        keys: [actualRest ? restKey : key], 
        duration: cleanDur + (actualRest ? "r" : ""), 
        stem_direction: stem 
    });

    if (isHit && vIdx === 0 && isAcc && element === 'hi-hat' && !actualRest) {
        note.addModifier(new VF.Articulation('ah').setPosition(3), 0);
    }
    if (cleanDur.includes('d')) VF.Dot.buildAndAttach([note], { all: true });
    
    // Set consistent key lines for all voices
    if (vIdx === 2) {
        note.setKeyLine(0, 2); // Bottom voice always on line 2
    } else if (vIdx === 1) {
        // Middle voice - keep notes at their natural positions (F/4 or C/5)
        // Don't adjust key lines for middle voice
    } else if (vIdx === 0) {
        // Top voice - keep at G/5 position
        // Don't adjust key lines for top voice
    }
    
    return note;
}

function generate(forceRandom = false) {
    const div = document.getElementById("output");
    div.innerHTML = "";
    const isTri = document.getElementById("triplet-mode").checked;
    const sub = isTri ? 3 : 4;
    const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
    renderer.resize(1000, 500);
    const ctx = renderer.getContext();
    const s1 = new VF.Stave(80, 80, 870).addClef("percussion").addTimeSignature("4/4").setContext(ctx).draw();
    const s2 = new VF.Stave(80, 260, 870);
    [0, 1, 3, 4].forEach(line => s2.setConfigForLine(line, { visible: false }));
    s2.addClef("percussion").addTimeSignature("4/4").setContext(ctx).draw();
    new VF.StaveConnector(s1, s2).setType(VF.StaveConnector.type.BRACKET).setContext(ctx).draw();

    if (forceRandom || !document.getElementById("freeze-bottom").checked || currentMid.length === 0) {
        currentMid = [];
        const pool = isTri ? tMidPool : sMidPool;
        for (let i = 0; i < 4; i++) currentMid.push(pool[Math.floor(Math.random() * pool.length)]);
    }

    const vData = [[], [], []], beams = [];
    const cymName = document.getElementById("cymbal-select").value;
    const footName = document.getElementById("foot-select").value;
    const isAccent = document.getElementById("accent-mode").checked;
    const element = document.getElementById('element-select').value;
    
    // Generate dynamic foot pattern for hi-hat accent mode
    let customFootPattern = null;
    if (isAccent && element === 'hi-hat') {
        customFootPattern = getFootPatternForHiHatAccents(cymName, isTri);
    }

    for (let b = 0; b < 4; b++) {
        for (let vIdx = 0; vIdx < 3; vIdx++) {
            let slice = [], pat;
            
            if (vIdx === 0) {
                // Top voice - cymbal pattern
                pat = (isTri ? tCym : sCym)[cymName];
            } else if (vIdx === 2) {
                // Bottom voice - foot pattern
                if (customFootPattern) {
                    // Use custom foot pattern for hi-hat accent mode
                    pat = customFootPattern;
                } else {
                    // Use selected foot pattern
                    pat = (isTri ? tFoot : sFoot)[footName];
                }
            } else {
                // Middle voice - kick/snare
                pat = currentMid[b];
            }
            
            if (vIdx === 0 && document.getElementById('accent-mode').checked && !isTri) {
                if (cymName === 'down beats' || cymName === 'up beats') pat = [1, 0, 1, 0];
            }
            for (let i = 0; i < sub; i++) slice.push(pat[(b * sub + i) % pat.length]);
            
            let isFullBeat = slice.slice(1).every(v => v === 0);
            if (isFullBeat) {
                let cDur = isTri ? "4d" : "4", hit = slice[0] === 1, acc = (vIdx === 0) ? getAccentLogic(cymName, b * sub, hit) : false;
                vData[vIdx].push(createNote(vIdx, cDur, hit, b, acc));
            } else {
                let bNotes = [];
                for (let i = 0; i < sub; i++) {
                    let hit = slice[i] === 1, acc = (vIdx === 0) ? getAccentLogic(cymName, b * sub + i, hit) : false, finalDur = isTri ? "8" : "16";
                    if (!isTri) {
                        let empty = 0; for (let j = i+1; j < sub; j++) if (slice[j] === 0) empty++; else break;
                        if (hit) { if (empty === 1) { finalDur = "8"; i+=1; } else if (empty === 2) { finalDur = "8d"; i+=2; } else if (empty === 3) { finalDur = "4"; i+=3; } }
                        else { if (empty === 1) { finalDur = "8r"; i+=1; } else if (empty === 2) { finalDur = "8dr"; i+=2; } else if (empty === 3) { finalDur = "4r"; i+=3; } else finalDur = "16r"; }
                    } else if (!hit) finalDur = "8r";
                    let n = createNote(vIdx, finalDur, hit, b, acc);
                    bNotes.push(n); vData[vIdx].push(n);
                }
                let nBeam = isTri ? bNotes : bNotes.filter(n => !n.isRest());
                if (nBeam.length >= 2) beams.push(new VF.Beam(nBeam));
            }
        }
    }
    const voices = vData.map(notes => new VF.Voice({num_beats: sub*4, beat_value: isTri ? 8 : 16}).setStrict(false).addTickables(notes));
    new VF.Formatter().joinVoices(voices.slice(0,2)).format(voices.slice(0,2), 800);
    new VF.Formatter().joinVoices([voices[2]]).format([voices[2]], 800);
    voices[0].draw(ctx, s1); voices[1].draw(ctx, s1); voices[2].draw(ctx, s2);
    beams.forEach(b => b.setContext(ctx).draw());
}

// --- AUDIO ENGINE ---
async function loadKit(kitName) {
    const names = ['kick', 'snare', 'hihat', 'hihat_open', 'hihat_foot', 'ride', 'ride_bell'];
    const newBuffers = {};
    console.log(`--- Loading Kit: ${kitName} ---`);
    for (const name of names) {
        try {
            const resp = await fetch(`samples/${kitName}/${name}.wav`);
            if (resp.ok) newBuffers[name] = await audioCtx.decodeAudioData(await resp.arrayBuffer());
        } catch (e) { console.error("Load error:", name, e); }
    }
    buffers = newBuffers;
    console.log("--- Kit Ready ---");
}

function playDrum(name, time, isAcc = false) {
    if (!audioCtx) return;
    let id = name;
    if (isAcc) { 
        if(name==='ride') id='ride_bell'; 
        if(name==='hihat') id='hihat_open'; 
    }
    
    if (buffers[id]) {
        const source = audioCtx.createBufferSource();
        const gainNode = audioCtx.createGain();
        source.buffer = buffers[id];

        // --- FIXED HI-HAT CHOKE LOGIC ---
        // Only apply choke logic for hi-hat sounds
        const isHiHat = id.includes('hihat');
        
        if (isHiHat) {
            // If there's a previous hi-hat ringing, choke it
            if (activeHH) {
                try {
                    // Determine fade time based on whether we're opening or closing
                    const isOpeningHit = id === 'hihat_open';
                    const fadeTime = isOpeningHit ? 0.08 : 0.03; 
                    
                    // Use linearRamp for a clean choke/clamp sound
                    activeHH.gainNode.gain.setValueAtTime(activeHH.gainNode.gain.value, time);
                    activeHH.gainNode.gain.linearRampToValueAtTime(0, time + fadeTime);
                    activeHH.source.stop(time + fadeTime + 0.01);
                } catch (e) {
                    console.error("Choke error:", e);
                }
            }
            // Track this hi-hat for future choking
            activeHH = { source: source, gainNode: gainNode };
        }
        // Ride cymbals are NOT tracked and will never be choked
        // ----------------------------

        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(time);
    } else {
        console.warn(`Buffer not found: ${id}`);
    }
}

function scheduleSounds(time) {
    const isTri = document.getElementById("triplet-mode").checked;
    const sub = isTri ? 3 : 4;
    const cymName = document.getElementById("cymbal-select").value;
    const footName = document.getElementById("foot-select").value;
    const el = document.getElementById('element-select').value;
    const isAccent = document.getElementById("accent-mode").checked;
    
    const cymPat = (isTri ? tCym : sCym)[cymName];
    
    // Determine foot pattern - use custom for hi-hat accent mode
    let footPat;
    if (isAccent && el === 'hi-hat') {
        footPat = getFootPatternForHiHatAccents(cymName, isTri);
    } else {
        footPat = (isTri ? tFoot : sFoot)[footName];
    }

    if (cymPat && cymPat[currentBeat % cymPat.length] === 1) {
        playDrum(el==='hi-hat'?'hihat':el, time, getAccentLogic(cymName, currentBeat, true));
    }
    const bIdx = Math.floor(currentBeat / sub) % 4;
    if (currentMid[bIdx] && currentMid[bIdx][currentBeat % sub] === 1) {
        playDrum(bIdx % 2 === 0 ? 'kick' : 'snare', time);
    }
    if (footPat && footPat[currentBeat % footPat.length] === 1) playDrum('hihat_foot', time, false);
}

function scheduler() {
    const tempo = document.getElementById('tempo-slider').value;
    const pocket = document.getElementById('pocket-slider').value / 100;
    const isTri = document.getElementById("triplet-mode").checked;
    const sps = (60.0 / tempo) / (isTri ? 3 : 4);

    while (nextNoteTime < audioCtx.currentTime + 0.15) {
        let subIdx = currentBeat % (isTri ? 3 : 4);
        let playTime = nextNoteTime;
        if (!isTri && (subIdx === 1 || subIdx === 3)) playTime += (sps * pocket);
        
        scheduleSounds(playTime);
        nextNoteTime += sps;
        currentBeat = (currentBeat + 1) % 48;
    }
    timerID = setTimeout(scheduler, 25);
}

// --- EVENT HANDLERS ---
window.onload = () => {
    updateMenus();
    document.querySelectorAll("select, input").forEach(el => {
        if (el.id === "kit-select") return;
        el.onchange = () => {
            if (el.id === "triplet-mode" || el.id === "accent-mode") {
                updateMenus();
                document.getElementById("pocket-slider").disabled = document.getElementById("triplet-mode").checked;
            }
            if (el.id === "element-select" || el.id === "cymbal-select" || el.id === "accent-mode") {
                updateFootPatternForHiHatAccents();
            }
            if (el.type !== 'range') generate();
        };
    });
    document.getElementById("gen-btn").onclick = () => generate(true);
    generate();
};

document.getElementById('tempo-slider').oninput = (e) => document.getElementById('bpm-display').innerText = e.target.value;
document.getElementById('pocket-slider').oninput = (e) => document.getElementById('pocket-display').innerText = e.target.value;

document.getElementById('metro-btn').onclick = async function() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    isPlaying = !isPlaying;

    if (isPlaying) {
        const kit = document.getElementById('kit-select').value;
        if (Object.keys(buffers).length === 0) {
            this.innerText = "Loading...";
            await loadKit(kit);
        }
        currentBeat = 0;
        nextNoteTime = audioCtx.currentTime + 0.05;
        this.innerText = "Stop Playback";
        scheduler();
    } else { 
        clearTimeout(timerID); 
        if (activeHH && activeHH.source) {
            try { activeHH.source.stop(); } catch(e) {}
        }
        activeHH = null; 
        this.innerText = "Play Beat"; 
    }
};

document.getElementById('kit-select').addEventListener('change', async (e) => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const btn = document.getElementById('metro-btn');
    btn.innerText = "ðŸ”„ Loading...";
    await loadKit(e.target.value);
    btn.innerText = isPlaying ? "Stop Playback" : "Play Beat";
});
</script>
</body>
</html>
